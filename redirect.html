/* ----------------- SLIDESHOW (manifest + lịch tuyệt đối) ----------------- */
    const GH_OWNER  = "tngon462";
    const GH_REPO   = "slide";
    const GH_BRANCH = "main";
    const GH_FOLDER = "slides";
    const SLIDE_DEFAULT_DURATION_SEC = 8; // mỗi slide mặc định
    let slides = [];
    let cumEdges = [];    // các mốc biên tích lũy (ms) trong 1 chu kỳ
    let periodMs = 0;     // tổng chu kỳ
    let currentIndex = -1;
    let startTs = null;   // mốc lịch tuyệt đối (server)
    let nextTimer = null;
    let watchdog = null;
    let manifestChecked = false;
    let slidesAvailable = false;
    function setSlideStatus(msg){
      const box = document.getElementById("slide-status");
      if (!box) return;
      if (msg && String(msg).trim()) { box.textContent = msg; box.style.display = "block"; }
      else { box.textContent = ""; box.style.display = "none"; }
    }
    function msFromDur(d){
      if (typeof d === "number") return Math.max(0, Math.round(d*1000));
      if (typeof d === "string" && /s$/i.test(d)) return Math.max(0, Math.round(parseFloat(d)*1000));
      return SLIDE_DEFAULT_DURATION_SEC * 1000;
    }
    function isVideoUrl(u){
      try { const ext = (new URL(u)).pathname.split('.').pop().toLowerCase();
        return ['mp4','webm','ogg','mov','m4v'].includes(ext);
      } catch { return false; }
    }
    function swapStage(el){
      const stage = document.getElementById("slide-stage"); if (!stage) return;
      while (stage.firstChild) stage.removeChild(stage.firstChild);
      stage.appendChild(el);
    }
    function showImage(src){
      const img = document.createElement("img");
      img.decoding = "async"; img.loading = "eager";
      img.onerror = () => setSlideStatus("Lỗi tải ảnh: " + src);
      img.onload = () => setSlideStatus("");
      img.src = src;
      swapStage(img);
    }
    function showVideo(src, offsetMs){
      const v = document.createElement("video");
      v.src = src; v.muted = true; v.playsInline = true; v.autoplay = true; v.preload = "auto"; v.controls = false;
      v.onerror = () => setSlideStatus("Lỗi tải video: " + src);
      v.addEventListener("loadedmetadata", () => {
        try {
          const offSec = Math.min((offsetMs||0)/1000, Math.max(0,(v.duration||0)-0.05));
          if (isFinite(offSec) && offSec > 0) v.currentTime = offSec;
        } catch(_) {}
        v.play().catch(()=>{});
        setSlideStatus("");
      });
      swapStage(v);
    }
    function buildEdges(){
      cumEdges = [];
      periodMs = 0;
      for (const s of slides){
        const d = msFromDur(s.duration);
        periodMs += d;
        cumEdges.push(periodMs); // cuối mỗi slide
      }
    }
    // Tính chỉ số slide theo lịch tuyệt đối
    function indexAt(nowMs){
      if (!slides.length || !periodMs || startTs==null) {
        const d0 = msFromDur(slides?.[0]?.duration || SLIDE_DEFAULT_DURATION_SEC);
        return {idx:0, offset:0, remain:d0, slideDur:d0, nextEdgeMs: nowMs + d0};
      }
      const elapsed = ((nowMs - startTs) % periodMs + periodMs) % periodMs; // [0, period)
      let idx = cumEdges.findIndex(edge => elapsed < edge);
      if (idx < 0) idx = slides.length - 1;
      const slideDur = msFromDur(slides?.[idx]?.duration);
      const startOfThis = cumEdges?.[idx] - slideDur;
      const offset = elapsed - startOfThis;          // đã trôi trong slide
      const nextEdgeAbs = startTs + cumEdges?.[idx];
      const remain = nextEdgeAbs - nowMs;
      return { idx, offset, remain, slideDur, nextEdgeMs: nextEdgeAbs };
    }
    // SỬA LOGIC CHÍNH TẠI ĐÂY: hẹn giờ tuyệt đối
    function renderAndArmToNextEdge(){
      if (nextTimer) clearTimeout(nextTimer);
      if (!slides.length || !periodMs || startTs == null) {
        console.warn("Slideshow not ready to render.");
        return;
      }
      const now = nowServerMs();
      const { idx, offset, nextEdgeMs } = indexAt(now);
      // Hiển thị slide nếu cần chuyển
      if (idx !== currentIndex){
        currentIndex = idx;
        const it = slides?.[idx];
        if (it) {
          if (it.type === "video") showVideo(it.src, offset);
          else showImage(it.src);
        }
      }
      // Tính toán thời gian chờ chính xác đến thời điểm chuyển slide tiếp theo
      const timeToWait = Math.max(0, nextEdgeMs - nowServerMs());
      nextTimer = setTimeout(renderAndArmToNextEdge, timeToWait);
    }
    // ===== Watchdog 500ms: kéo về đúng slide nếu timer bị lệch/đóng băng =====
    function startSyncWatchdog(){
      if (watchdog) clearInterval(watchdog);
      watchdog = setInterval(() => {
        if (!slides.length || !periodMs || startTs==null) return;
        const { idx } = indexAt(nowServerMs());
        if (idx !== currentIndex) {
          console.log("Watchdog triggered: Syncing slide due to time drift.");
          renderAndArmToNextEdge(); // Gọi render lại để đồng bộ
        }
      }, 500);
    }
    async function loadSlidesFromManifest(){
      const base = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${GH_FOLDER}/`;
      const url   = base + "manifest.json?cb=" + Date.now();
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) {
          setSlideStatus("Không tải được manifest.json (HTTP " + res.status + ")");
          showGlobalStatus("Không tải được manifest.json (HTTP " + res.status + ")");
          return false;
        }
        let arr = await res.json();
        if (!Array.isArray(arr)) {
          setSlideStatus("manifest.json không đúng định dạng (phải là mảng).");
          showGlobalStatus("manifest.json không đúng định dạng (phải là mảng).");
          return false;
        }
        const allowed = /\.(jpe?g|png|gif|mp4|webm|mov|m4v)$/i;
        const items = arr
          .map(item => {
            if (typeof item === "string") {
              const name = item.trim();
              if (!name) return null;
              return { src: base + name, name, duration: SLIDE_DEFAULT_DURATION_SEC };
            }
            if (item && typeof item === "object" && item.src) {
              const name = String(item.src).trim();
              if (!name) return null;
              const src = name.startsWith("http") ? name : (base + name);
              const duration = Number(item.duration) > 0 ? Number(item.duration) : SLIDE_DEFAULT_DURATION_SEC;
              return { src, name, duration };
            }
            return null;
          })
          .filter(Boolean)
          .filter(it => allowed.test(it.name));
        if (!items.length) {
          setSlideStatus("Không tìm thấy ảnh/video hợp lệ trong manifest.json.");
          showGlobalStatus("Không tìm thấy ảnh/video hợp lệ trong manifest.json.");
          return false;
        }
        slides = items.map(it => ({ type: isVideoUrl(it.src) ? "video" : "image", src: it.src, duration: it.duration }));
        buildEdges();
        setSlideStatus(""); showGlobalStatus("");
        return true;
      } catch(err){
        setSlideStatus("Lỗi khi tải/đọc manifest.json.");
        showGlobalStatus("Lỗi khi tải/đọc manifest.json.");
        return false;
      }
    }
    // Tạo/đọc “mốc lịch” tuyệt đối trên server (đặt 1 lần bằng ServerValue.TIMESTAMP)
    async function ensureStartTs(){
      try {
        if (!rtdb) { startTs = nowServerMs(); return; }
        const ref = rtdb.ref("slideshow/startTs");
        // nghe mốc từ server
        ref.on("value", snap => {
          const val = snap.val();
          if (typeof val === "number" && val > 0) startTs = val;
        });
        // đặt mốc bằng transaction (chỉ khi chưa có)
        await ref.transaction(curr => {
          if (curr === null || curr === undefined || typeof curr !== "number" || curr <= 0) {
            return firebase.database.ServerValue.TIMESTAMP;
          }
          return curr;
        });
        // đọc lại giá trị chuẩn từ server
        const s = await ref.get();
        const t = s.val();
        if (typeof t === "number" && t > 0) startTs = t;
        else startTs = nowServerMs(); // fallback
      } catch(_){
        startTs = nowServerMs();
      }
    }
    async function initSlidesThenMaybeShow(){
      // tải manifest (retry nhẹ)
      let ok = false;
      if (!manifestChecked) {
        ok = await loadSlidesFromManifest();
        if (!ok) {
          await new Promise(r => setTimeout(r, 800));
          ok = await loadSlidesFromManifest();
        }
        manifestChecked = true;
        slidesAvailable = ok;
      } else ok = slidesAvailable;
      if (ok) {
        if (startTs == null) { // có slide thì mới cần mốc
          await ensureStartTs(); // mốc lịch tuyệt đối
          currentIndex = -1;
          if (nextTimer) clearTimeout(nextTimer);
          renderAndArmToNextEdge();
          startSyncWatchdog(); // ⭐ quan trọng: watchdog kéo lệch về đúng
        }
        showScreen("start-slideshow-screen");
      } else {
        showScreen("start-screen");
      }
      resetIdleTimer(); // (re)start idle 59s
    }
 ```

***

**Giải thích các thay đổi:**

* Hàm `renderAndArmToNextEdge()` giờ đây tính toán chính xác thời gian cần chờ đến khi slide tiếp theo bắt đầu (`nextEdgeMs - nowServerMs()`) và sử dụng `setTimeout` với thời gian này.
* `watchdog` vẫn hoạt động để kiểm tra sai lệch và gọi `renderAndArmToNextEdge()` nếu cần đồng bộ lại.

Hãy thử lại với phiên bản code này. Tôi tin rằng vấn đề đồng bộ sẽ được giải quyết. Nếu vẫn có vấn đề, xin vui lòng cho tôi biết chi tiết cụ thể về những gì bạn quan sát được.
