# QRback_test_v2.py - Server WebSocket với chức năng thông báo hết hạn mã QR

import asyncio
import websockets
import json
import time

# Dictionary để lưu trữ các kết nối client theo số bàn
connected_clients = {}

async def handler(websocket):
    """
    Xử lý kết nối từ client WebSocket.
    """
    client_address = websocket.remote_address
    print(f"--- Client mới kết nối từ {client_address} ---")
    
    try:
        # Chờ tin nhắn đầu tiên từ client để xác định bàn
        # Tin nhắn này phải có định dạng {"action": "client_connected", "ban": 10}
        initial_message = await asyncio.wait_for(websocket.recv(), timeout=10.0)
        message_data = json.loads(initial_message)
        
        ban_id = message_data.get("ban")
        action = message_data.get("action")
        
        if action == "client_connected" and ban_id:
            print(f"✅ Đã xác định: Client ở Bàn {ban_id} đã kết nối.")
            connected_clients[ban_id] = websocket
            
            # Gửi một tin nhắn xác nhận ngay lập tức cho client này
            await websocket.send(json.dumps({"ban": ban_id, "test_message": "connected"}))
            print(f"✅ Đã gửi tin nhắn xác nhận đến Bàn {ban_id}.")
        else:
            print(f"❌ Nhận tin nhắn không hợp lệ: {initial_message}. Đóng kết nối.")
            await websocket.close(code=1003, reason="Invalid message format")
            return

        # Vòng lặp để nhận các tin nhắn khác từ client
        async for message in websocket:
            print(f"➡️ Nhận tin nhắn từ Bàn {ban_id}: {message}")
            # Ở đây bạn có thể thêm logic xử lý tin nhắn trong tương lai
            
    except asyncio.TimeoutError:
        print(f"❌ Lỗi: Không nhận được tin nhắn xác định bàn trong 10 giây. Đóng kết nối.")
    except websockets.exceptions.ConnectionClosed as e:
        print(f"--- Client Bàn {ban_id} đã ngắt kết nối. Mã lỗi: {e.code}, Lý do: {e.reason} ---")
    except json.JSONDecodeError:
        print("❌ Lỗi: Không thể phân tích cú pháp tin nhắn JSON. Đóng kết nối.")
    except Exception as e:
        print(f"❌ Lỗi không xác định: {e}")
    finally:
        # Xóa client khi ngắt kết nối
        if ban_id in connected_clients:
            del connected_clients[ban_id]
            print(f"--- Đã xóa Bàn {ban_id} khỏi danh sách kết nối ---")

async def send_expired_message(ban_id):
    """
    Gửi tin nhắn hết hạn tới một client cụ thể.
    """
    if ban_id in connected_clients:
        websocket = connected_clients[ban_id]
        try:
            message = json.dumps({"action": "expired"})
            await websocket.send(message)
            print(f"📢 Đã gửi tin nhắn hết hạn đến Bàn {ban_id}.")
            return True
        except websockets.exceptions.ConnectionClosed as e:
            print(f"❌ Lỗi: Không thể gửi tin nhắn. Kết nối đến Bàn {ban_id} đã đóng. Mã lỗi: {e.code}")
            return False
    else:
        print(f"⚠️ Không tìm thấy kết nối cho Bàn {ban_id}.")
        return False

async def simulate_expiry():
    """
    Hàm mô phỏng việc mã QR hết hạn cho bàn 10.
    """
    # Chờ 30 giây để mô phỏng một khoảng thời gian trước khi hết hạn
    await asyncio.sleep(30)
    print("\n--- MÔ PHỎNG: Đã hết thời gian sử dụng mã QR cho Bàn 10 ---")
    await send_expired_message(10)

async def main():
    """
    Khởi động server WebSocket và một hàm mô phỏng.
    """
    # Khởi động server
    server_task = websockets.serve(handler, "0.0.0.0", 8765)
    
    # Khởi động hàm mô phỏng hết hạn
    expiry_task = simulate_expiry()

    print("🚀 Server WebSocket đang chạy tại ws://0.0.0.0:8765...")
    print("Hãy chạy file redirect_test.html trên tablet và chọn số bàn.")
    print("Mô phỏng: Tin nhắn hết hạn sẽ được gửi đến Bàn 10 sau 30 giây.")
    
    # Chạy cả hai tác vụ đồng thời
    await asyncio.gather(server_task, expiry_task)

if __name__ == "__main__":
    asyncio.run(main())
