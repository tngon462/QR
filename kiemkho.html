<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Ki·ªÉm kho T-NGON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 10px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 1.2rem;
      margin-bottom: 8px;
    }
    .field {
      display: flex;
      flex-direction: column;
      margin-bottom: 8px;
    }
    .inline {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    label {
      font-size: 13px;
      margin-bottom: 2px;
    }
    input, select, button {
      padding: 8px;
      font-size: 14px;
    }
    button {
      cursor: pointer;
      margin-right: 6px;
      margin-bottom: 6px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tbody tr:nth-child(even) {
      background: #fafafa;
    }
    .barcode-input {
      font-size: 16px;
      font-weight: bold;
      flex: 1;
    }
    .small {
      font-size: 12px;
      color: #666;
    }

    /* Camera qu√©t m√£ (barcode) */
    .camera-preview {
      display: none;
      width: 100%;
      max-height: 300px;
      border: 1px solid #ccc;
      margin-top: 6px;
      border-radius: 4px;
    }

    /* Khung ch·ª•p ·∫£nh s·∫£n ph·∫©m 250x250 */
    .photo-frame {
      display: none;
      width: 250px;
      height: 250px;
      border: 2px solid #999;
      border-radius: 4px;
      margin-top: 6px;
      overflow: hidden;
    }
    .photo-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #stopCameraBtn, #takePhotoBtn, #closePhotoBtn {
      display: none;
    }
    .img-thumb {
      display: none;
      margin-top: 4px;
      width: 120px;
      height: 120px;
      object-fit: cover;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .img-table-thumb {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 3px;
    }

    /* Dropdown danh m·ª•c custom */
    .category-wrapper {
      position: relative;
      width: 100%;
    }
    .category-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 180px;
      overflow-y: auto;
      border: 1px solid #ccc;
      background: #fff;
      z-index: 10;
      font-size: 13px;
      display: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .category-item {
      padding: 4px 6px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .category-item:hover {
      background: #eee;
    }
    .category-item.add-new {
      font-style: italic;
    }

    /* K·∫øt qu·∫£ t√¨m ki·∫øm (t√™n / m√£ g·∫ßn ƒë√∫ng) */
    .search-results {
      margin-top: 4px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px;
      max-height: 200px;
      overflow-y: auto;
      background: #fafafa;
      font-size: 12px;
    }
    .search-results table {
      width: 100%;
      border-collapse: collapse;
    }
    .search-results th,
    .search-results td {
      border: 1px solid #eee;
      padding: 2px 4px;
      text-align: left;
    }
    .search-results-title {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .search-results-empty {
      font-style: italic;
      color: #666;
    }
    .search-result-row {
      cursor: pointer;
    }
    .search-result-row:hover {
      background: #e6f3ff;
    }

    /* H√†ng SL / T·ªìn / Gi√° */
    .small-input-row input.short-input {
      width: 5ch;
      min-width: 5ch;
      max-width: 7ch;
      text-align: right;
    }
  </style>
</head>
<body>
  <h1>App ki·ªÉm kho (beta)</h1>

  <!-- Form nh·∫≠p -->
  <div class="field">
    <label>M√£ v·∫°ch (qu√©t ho·∫∑c g√µ):</label>
    <div class="inline">
      <input id="barcodeInput" class="barcode-input" autofocus />
      <button id="cameraBtn" type="button">üì∑ Qu√©t m√£</button>
    </div>
    <button id="editBarcodeModeBtn" type="button">‚úèÔ∏è S·ª≠a m√£</button>
    <div class="small">
      ƒê·∫ßu ƒë·ªçc: b·∫Øn chu·ªói s·ªë + Enter, d√π con tr·ªè ƒëang ·ªü ƒë√¢u app c≈©ng nh·∫≠n.<br>
      N·∫øu m√£ ƒë√£ c√≥ ‚Üí t·ª± ƒë∆∞a th√¥ng tin (k√®m ·∫£nh n·∫øu c√≥) l√™n form ph√≠a tr√™n ƒë·ªÉ s·ª≠a.
    </div>
    <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
    <button id="stopCameraBtn" type="button">T·∫Øt camera qu√©t</button>
  </div>

  <div class="field">
    <label>T√™n s·∫£n ph·∫©m:</label>
    <div class="inline">
      <input id="nameInput" />
      <button id="searchNameBtn" type="button">üîç T√¨m</button>
    </div>
    <div id="searchResults" class="search-results"></div>
  </div>

  <div class="field">
    <label>·∫¢nh s·∫£n ph·∫©m:</label>
    <div class="inline">
      <input id="imageInput" placeholder="Base64 ho·∫∑c URL (ƒë·ªÉ h·ªá th·ªëng d√πng, th∆∞·ªùng kh√¥ng c·∫ßn ch·ªânh)" />
      <button id="photoBtn" type="button">üì∏ Ch·ª•p ·∫£nh</button>
    </div>
    <div class="small">
      Khi ch·ª•p, h·ªá th·ªëng l∆∞u ·∫£nh k√≠ch th∆∞·ªõc ~250√ó250 (JPEG, base64) v√†o CSV v√† hi·ªÉn th·ªã b√™n d∆∞·ªõi.<br>
      N·∫øu ·∫£nh sai ‚Üí ch·ª•p l·∫°i ho·∫∑c ch·ªânh tr∆∞·ªùng ·∫£nh th·ªß c√¥ng.
    </div>
    <div id="photoFrame" class="photo-frame">
      <video id="photoPreview" class="photo-preview" autoplay playsinline></video>
    </div>
    <div>
      <button id="takePhotoBtn" type="button">Ch·ª•p & l∆∞u v√†o CSV</button>
      <button id="closePhotoBtn" type="button">ƒê√≥ng camera ·∫£nh</button>
    </div>
    <canvas id="photoCanvas" style="display:none;"></canvas>
    <img id="imageThumb" class="img-thumb" alt="·∫¢nh s·∫£n ph·∫©m" />
  </div>

  <div class="field">
    <label>Danh m·ª•c:</label>
    <div class="category-wrapper">
      <input id="categoryInput" placeholder="Ch·ªçn ho·∫∑c g√µ danh m·ª•c..." autocomplete="off" />
      <div id="categoryDropdown" class="category-dropdown"></div>
    </div>
    <div class="small">Danh m·ª•c s·∫Ω g·ª£i √Ω t·ª´ file CSV import. N·∫øu kh√¥ng c√≥ th√¨ g√µ tay.</div>
  </div>

  <div class="field">
    <label>S·ªë l∆∞·ª£ng / T·ªìn kho / Gi√° b√°n:</label>
    <div class="inline small-input-row">
      <input id="qtyInput"   type="number" value="1" min="0" class="short-input"  placeholder="SL" />
      <input id="stockInput" type="number" min="0"        class="short-input"  placeholder="T·ªìn" />
      <input id="priceInput" type="number" min="0" step="1" class="short-input" placeholder="Gi√°" />
    </div>
  </div>

  <div class="field">
    <label>Ghi ch√∫:</label>
    <input id="noteInput" />
  </div>

  <div class="field">
    <div>
      <button id="saveBtn">L∆∞u / Th√™m m·ªõi</button>
      <button id="resetBtn">X√≥a form</button>
    </div>
  </div>

  <div class="field">
    <label>Import CSV hi·ªán c√≥ (t·ª´ file m√°y):</label>
    <input id="csvFileInput" type="file" accept=".csv" />
    <div class="small">
      CSV chu·∫©n: <b>barcode,name,image,category,price,qty,stock,note,updated_at</b><br>
      C·ªôt <b>image</b> c√≥ th·ªÉ l√† base64 (·∫£nh thu nh·ªè) ho·∫∑c URL.
    </div>
  </div>

  <div class="field">
    <div>
      <button id="exportBtn">Export CSV (t·∫£i file v·ªÅ m√°y)</button>
      <button id="githubPullBtn">‚¨á T·∫£i CSV t·ª´ GitHub</button>
      <button id="githubPushBtn">‚¨Ü L∆∞u CSV l√™n GitHub</button>
    </div>
    <div class="small">
      L·∫ßn ƒë·∫ßu d√πng GitHub s·∫Ω h·ªèi token (PAT) ‚Üí l∆∞u tr√™n thi·∫øt b·ªã (localStorage).<br>
      D·ªØ li·ªáu c≈©ng ƒë∆∞·ª£c l∆∞u t·∫°m trong tr√¨nh duy·ªát (localStorage) nh∆∞ tr∆∞·ªõc.
    </div>
  </div>

  <!-- B·∫£ng d·ªØ li·ªáu -->
  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>M√£ v·∫°ch</th>
        <th>T√™n s·∫£n ph·∫©m</th>
        <th>·∫¢nh</th>
        <th>Danh m·ª•c</th>
        <th>Gi√° b√°n</th>
        <th>S·ªë l∆∞·ª£ng</th>
        <th>T·ªìn kho</th>
        <th>Ghi ch√∫</th>
        <th>C·∫≠p nh·∫≠t l√∫c</th>
      </tr>
    </thead>
    <tbody id="itemsBody"></tbody>
  </table>

  <script>
    const barcodeInput   = document.getElementById('barcodeInput');
    const nameInput      = document.getElementById('nameInput');
    const imageInput     = document.getElementById('imageInput');
    const categoryInput  = document.getElementById('categoryInput');
    const qtyInput       = document.getElementById('qtyInput');
    const stockInput     = document.getElementById('stockInput');
    const priceInput     = document.getElementById('priceInput');
    const noteInput      = document.getElementById('noteInput');
    const saveBtn        = document.getElementById('saveBtn');
    const resetBtn       = document.getElementById('resetBtn');
    const csvFileInput   = document.getElementById('csvFileInput');
    const exportBtn      = document.getElementById('exportBtn');
    const itemsBody      = document.getElementById('itemsBody');

    const cameraBtn      = document.getElementById('cameraBtn');
    const cameraPreview  = document.getElementById('cameraPreview');
    const stopCameraBtn  = document.getElementById('stopCameraBtn');

    const photoBtn       = document.getElementById('photoBtn');
    const photoFrame     = document.getElementById('photoFrame');
    const photoPreview   = document.getElementById('photoPreview');
    const takePhotoBtn   = document.getElementById('takePhotoBtn');
    const closePhotoBtn  = document.getElementById('closePhotoBtn');
    const photoCanvas    = document.getElementById('photoCanvas');
    const imageThumb     = document.getElementById('imageThumb');

    const categoryDropdown = document.getElementById('categoryDropdown');

    const githubPullBtn  = document.getElementById('githubPullBtn');
    const githubPushBtn  = document.getElementById('githubPushBtn');

    const searchNameBtn  = document.getElementById('searchNameBtn');
    const searchResults  = document.getElementById('searchResults');

    const editBarcodeModeBtn = document.getElementById('editBarcodeModeBtn');

    // items: { barcode, name, image, category, price, qty, stock, note, updated_at }
    let items = [];
    let categoryOptions = [];
    let formDirty = false; // true n·∫øu form ƒëang ch·ªânh s·ª≠a
    let editBarcodeMode = false; // true = t·∫Øt auto qu√©t, ƒë·∫ßu ƒë·ªçc nh∆∞ b√†n ph√≠m th∆∞·ªùng

    // ===== C·∫•u h√¨nh GitHub =====
    const GH_OWNER  = 'tngon462';
    const GH_REPO   = 'QR';
    const GH_BRANCH = 'main';
    const GH_PATH   = 'kiemkho-data.csv';

    const INTERNAL_CODE = 'tngon';

    let githubToken = localStorage.getItem('kiemkho_github_token') || '';
    let lastGithubSha = null;

    async function ensureGithubToken() {
      if (!githubToken) {
        const t = prompt('Nh·∫≠p GitHub Personal Access Token (PAT) ƒë·ªÉ ƒë·ªìng b·ªô CSV v·ªõi repo QR:');
        if (!t) return false;
        githubToken = t.trim();
        localStorage.setItem('kiemkho_github_token', githubToken);
      }
      return true;
    }

    // ===== Camera / BarcodeDetector =====
    let cameraStream = null;
    let scanning = false;
    let barcodeDetector = null;
    if ('BarcodeDetector' in window) {
      try {
        barcodeDetector = new BarcodeDetector({
          formats: ['ean_13', 'ean_8', 'code_128', 'code_39', 'upc_a', 'upc_e', 'qr_code']
        });
      } catch (e) {
        console.warn('BarcodeDetector init error', e);
        barcodeDetector = null;
      }
    }

    // Camera ch·ª•p ·∫£nh s·∫£n ph·∫©m
    let photoStream = null;

    // Buffer ƒë·ªÉ b·∫Øt chu·ªói qu√©t t·ª´ ƒë·∫ßu ƒë·ªçc
    let scanBuffer = '';
    let lastScanTime = 0;
    const SCAN_TIMEOUT = 300; // ms

    function loadFromLocalStorage() {
      const raw = localStorage.getItem('inventoryItems_v5');
      if (!raw) return;
      try {
        items = JSON.parse(raw);
        renderTable();
        rebuildCategoryList();
      } catch (e) {
        console.error('LS parse error', e);
      }
    }

    function saveToLocalStorage() {
      localStorage.setItem('inventoryItems_v5', JSON.stringify(items));
    }

    function nowString() {
      const d = new Date();
      const pad = (n) => (n < 10 ? '0' + n : n);
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} `
           + `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    // Chu·∫©n h√≥a chu·ªói ƒë·ªÉ so s√°nh kh√¥ng d·∫•u
    function normalizeStr(str) {
      return (str || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/[^0-9a-z\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function isProbablyBase64(str) {
      return /^[A-Za-z0-9+/=]+$/.test(str) && str.length > 100;
    }

    function makeImageSrc(imageValue) {
      if (!imageValue) return null;
      const v = imageValue.trim();
      if (!v) return null;
      if (v.startsWith('http') || v.startsWith('data:')) {
        return v;
      }
      if (isProbablyBase64(v)) {
        return 'data:image/jpeg;base64,' + v;
      }
      return null;
    }

    function updateImageThumbFromInput() {
      const src = makeImageSrc(imageInput.value || '');
      if (src) {
        imageThumb.src = src;
        imageThumb.style.display = 'block';
      } else {
        imageThumb.src = '';
        imageThumb.style.display = 'none';
      }
    }

    function renderTable() {
      itemsBody.innerHTML = '';
      items.forEach((item, idx) => {
        const tr = document.createElement('tr');
        tr.dataset.barcode = item.barcode || '';

        const imgSrc = makeImageSrc(item.image || '');
        let imgCell = '';
        if (imgSrc) {
          imgCell = `<img src="${imgSrc}" class="img-table-thumb" alt="·∫¢nh" />`;
        } else if (item.image) {
          imgCell = item.image;
        }

        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${item.barcode || ''}</td>
          <td>${item.name || ''}</td>
          <td>${imgCell}</td>
          <td>${item.category || ''}</td>
          <td>${item.price !== '' && item.price != null ? item.price : ''}</td>
          <td>${item.qty ?? ''}</td>
          <td>${item.stock ?? ''}</td>
          <td>${item.note || ''}</td>
          <td>${item.updated_at || ''}</td>
        `;

        tr.addEventListener('click', () => {
          loadItemToForm(item);
          barcodeInput.focus();
          barcodeInput.select();
        });

        itemsBody.appendChild(tr);
      });
    }

    function clearSearchResults() {
      searchResults.innerHTML = '';
    }

    function loadItemToForm(item) {
      barcodeInput.value  = item.barcode || '';
      nameInput.value     = item.name || '';
      imageInput.value    = item.image || '';
      categoryInput.value = item.category || '';
      qtyInput.value      = item.qty ?? 0;
      stockInput.value    = item.stock ?? '';
      priceInput.value    = (item.price !== '' && item.price != null) ? item.price : '';
      noteInput.value     = item.note || '';
      updateImageThumbFromInput();
      formDirty = false;
      clearSearchResults();
    }

    function resetForm() {
      barcodeInput.value  = '';
      nameInput.value     = '';
      imageInput.value    = '';
      categoryInput.value = '';
      qtyInput.value      = '1';
      stockInput.value    = '';
      priceInput.value    = '';
      noteInput.value     = '';
      updateImageThumbFromInput();
      formDirty = false;
      clearSearchResults();
      barcodeInput.focus();
    }

    function upsertItemFromForm(auto = false) {
      const barcode  = (barcodeInput.value || '').trim();
      if (!barcode) {
        if (!auto) {
          alert('Ch∆∞a c√≥ m√£ v·∫°ch');
          barcodeInput.focus();
        }
        return;
      }

      const name     = (nameInput.value || '').trim();
      const image    = (imageInput.value || '').trim();
      const category = (categoryInput.value || '').trim();
      let qty        = parseInt(qtyInput.value, 10);
      if (isNaN(qty)) qty = 0;
      let stock      = parseInt(stockInput.value, 10);
      if (isNaN(stock)) stock = '';
      let price      = parseFloat(priceInput.value);
      if (isNaN(price)) price = '';

      const note     = (noteInput.value || '').trim();

      let existing = items.find((i) => i.barcode === barcode);

      if (existing) {
        existing.name       = name;
        existing.image      = image;
        existing.category   = category;
        existing.price      = price;
        existing.qty        = qty;
        existing.stock      = stock;
        existing.note       = note;
        existing.updated_at = nowString();
      } else {
        existing = {
          barcode,
          name,
          image,
          category,
          price,
          qty,
          stock,
          note,
          updated_at: nowString(),
        };
        items.push(existing);
      }

      saveToLocalStorage();
      rebuildCategoryList();
      renderTable();
      formDirty = false;
    }

    // Auto-save: tr·∫£ v·ªÅ true n·∫øu c√≥ l∆∞u (ƒë·ªÉ bi·∫øt c√≥ c·∫ßn push GitHub)
    function autoSaveIfDirty() {
      const currentBarcode = (barcodeInput.value || '').trim();
      if (!currentBarcode) return false;
      if (!formDirty) return false;
      upsertItemFromForm(true);
      return true;
    }

    // Hi·ªÉn th·ªã k·∫øt qu·∫£ t√¨m ki·∫øm (theo t√™n ho·∫∑c m√£)
    function showSearchResults(results, type, keyword) {
      searchResults.innerHTML = '';

      if (!results || !results.length) {
        const div = document.createElement('div');
        div.className = 'search-results-empty';
        div.textContent = 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p.';
        searchResults.appendChild(div);
        return;
      }

      const title = document.createElement('div');
      title.className = 'search-results-title';
      if (type === 'name') {
        title.textContent = `K·∫øt qu·∫£ t√¨m theo t√™n "${keyword}":`;
      } else if (type === 'barcode-partial') {
        title.textContent = `M√£ v·∫°ch g·∫ßn ƒë√∫ng "${keyword}" ‚Äì ch·ªçn 1 d√≤ng:`;
      } else if (type === 'barcode-exact') {
        title.textContent = `C√≥ nhi·ªÅu m√£ tr√πng "${keyword}" ‚Äì ch·ªçn 1 d√≤ng:`;
      } else {
        title.textContent = 'K·∫øt qu·∫£ t√¨m ki·∫øm:';
      }
      searchResults.appendChild(title);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>M√£ v·∫°ch</th><th>T√™n</th><th>Danh m·ª•c</th></tr>';
      table.appendChild(thead);
      const tbody = document.createElement('tbody');

      results.forEach((item) => {
        const tr = document.createElement('tr');
        tr.className = 'search-result-row';
        tr.innerHTML = `
          <td>${item.barcode || ''}</td>
          <td>${item.name || ''}</td>
          <td>${item.category || ''}</td>
        `;
        tr.addEventListener('click', () => {
          loadItemToForm(item);
          barcodeInput.value = item.barcode || '';
          barcodeInput.focus();
          barcodeInput.select();
          clearSearchResults();
        });
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      searchResults.appendChild(table);
    }

    // T√¨m ki·∫øm theo t√™n (kh√¥ng ph√¢n bi·ªát d·∫•u)
    function searchByName() {
      const keyword = (nameInput.value || '').trim();
      if (!keyword) {
        alert('Nh·∫≠p t√™n s·∫£n ph·∫©m c·∫ßn t√¨m');
        nameInput.focus();
        return;
      }
      const kwNorm = normalizeStr(keyword);
      const results = items.filter((item) => {
        const nameNorm = normalizeStr(item.name || '');
        return nameNorm.includes(kwNorm);
      });
      showSearchResults(results, 'name', keyword);
    }

    function handleBarcodeEnter() {
      clearSearchResults();
      const barcode = (barcodeInput.value || '').trim();
      if (!barcode) return;

      // 1. ∆Øu ti√™n tr√πng ch√≠nh x√°c
      const exactMatches = items.filter(i => i.barcode === barcode);
      if (exactMatches.length === 1) {
        loadItemToForm(exactMatches[0]);
        return;
      }
      if (exactMatches.length > 1) {
        showSearchResults(exactMatches, 'barcode-exact', barcode);
        return;
      }

      // 2. Kh√¥ng c√≥ tr√πng ch√≠nh x√°c ‚Üí t√¨m c√°c m√£ C√ì CH·ª®A chu·ªói barcode
      const partialMatches = items.filter(i =>
        i.barcode && i.barcode.includes(barcode)
      );
      if (partialMatches.length === 1) {
        loadItemToForm(partialMatches[0]);
        return;
      }
      if (partialMatches.length > 1) {
        showSearchResults(partialMatches, 'barcode-partial', barcode);
        return;
      }

      // 3. Kh√¥ng c√≥ g√¨ ‚Üí coi nh∆∞ m√£ m·ªõi, reset c√°c tr∆∞·ªùng kh√°c
      nameInput.value     = '';
      imageInput.value    = '';
      categoryInput.value = '';
      qtyInput.value      = '1';
      stockInput.value    = '';
      priceInput.value    = '';
      noteInput.value     = '';
      updateImageThumbFromInput();
      formDirty = false;
    }

    function parseCsv(text) {
      const lines = text.split(/\r?\n/).filter((l) => l.trim() !== '');
      if (lines.length === 0) return;

      const header = lines[0].split(',');
      const getIdx = (name) => header.indexOf(name);

      const idxBarcode  = getIdx('barcode');
      const idxName     = getIdx('name');
      const idxImage    = getIdx('image');
      const idxCategory = getIdx('category');
      const idxPrice    = getIdx('price');
      const idxQty      = getIdx('qty');
      const idxStock    = getIdx('stock');
      const idxNote     = getIdx('note');
      const idxUpdated  = getIdx('updated_at');

      items = [];

      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',');
        if (!cols.length) continue;
        const barcode = cols[idxBarcode] || '';
        if (!barcode) continue;

        let price = '';
        if (idxPrice >= 0 && cols[idxPrice]) {
          const p = parseFloat(cols[idxPrice]);
          price = isNaN(p) ? '' : p;
        }

        items.push({
          barcode: barcode,
          name: idxName >= 0 ? (cols[idxName] || '') : '',
          image: idxImage >= 0 ? (cols[idxImage] || '') : '',
          category: idxCategory >= 0 ? (cols[idxCategory] || '') : '',
          price: price,
          qty: idxQty >= 0 && cols[idxQty] ? (parseInt(cols[idxQty], 10) || 0) : 0,
          stock: idxStock >= 0 && cols[idxStock] ? (parseInt(cols[idxStock], 10) || 0) : '',
          note: idxNote >= 0 ? (cols[idxNote] || '') : '',
          updated_at: idxUpdated >= 0 ? (cols[idxUpdated] || '') : '',
        });
      }

      saveToLocalStorage();
      rebuildCategoryList();
      renderTable();
      formDirty = false;
      clearSearchResults();
    }

    function buildCsvFromItems() {
      if (!items.length) return '';
      const header = 'barcode,name,image,category,price,qty,stock,note,updated_at';
      const lines = [header];

      items.forEach((item) => {
        const row = [
          item.barcode || '',
          (item.name || '').replace(/,/g, ' '),
          (item.image || ''),
          (item.category || '').replace(/,/g, ' '),
          (item.price !== '' && item.price != null ? item.price : ''),
          item.qty ?? 0,
          (item.stock !== '' && item.stock != null ? item.stock : ''),
          (item.note || '').replace(/,/g, ' '),
          item.updated_at || '',
        ];
        lines.push(row.join(','));
      });

      return lines.join('\n');
    }

    function exportCsv() {
      if (!items.length) {
        alert('Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ export');
        return;
      }
      const csvText = buildCsvFromItems();
      const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hang-kiem-kho.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function rebuildCategoryList() {
      const set = new Set();
      items.forEach((item) => {
        if (item.category && item.category.trim()) {
          set.add(item.category.trim());
        }
      });
      categoryOptions = Array.from(set).sort();
      buildCategoryDropdown('');
    }

    function buildCategoryDropdown(filterText = '') {
      categoryDropdown.innerHTML = '';

      const ft = (filterText || '').trim().toLowerCase();
      let filtered = categoryOptions;
      if (ft) {
        filtered = categoryOptions.filter(cat =>
          cat.toLowerCase().includes(ft)
        );
      }

      filtered.forEach((cat) => {
        const div = document.createElement('div');
        div.className = 'category-item';
        div.textContent = cat;
        div.title = cat;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          categoryInput.value = cat;
          hideCategoryDropdown();
          formDirty = true;
        });
        categoryDropdown.appendChild(div);
      });

      const addNew = document.createElement('div');
      addNew.className = 'category-item add-new';
      addNew.textContent = 'Ôºã Th√™m danh m·ª•c m·ªõi‚Ä¶';
      addNew.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const name = prompt('Nh·∫≠p t√™n danh m·ª•c m·ªõi:');
        if (name) {
          const trimmed = name.trim();
          if (trimmed) {
            categoryInput.value = trimmed;
            if (!categoryOptions.includes(trimmed)) {
              categoryOptions.push(trimmed);
              categoryOptions.sort();
            }
            formDirty = true;
          }
        }
        hideCategoryDropdown();
      });
      categoryDropdown.appendChild(addNew);
    }

    function showCategoryDropdown(showAll = false) {
      const filter = showAll ? '' : categoryInput.value;
      buildCategoryDropdown(filter);
      if (categoryOptions.length || categoryDropdown.children.length) {
        categoryDropdown.style.display = 'block';
      }
    }

    function hideCategoryDropdown() {
      categoryDropdown.style.display = 'none';
    }

    // ===== GitHub sync =====

    function toBase64Unicode(str) {
      return btoa(unescape(encodeURIComponent(str)));
    }

    function fromBase64Unicode(b64) {
      return decodeURIComponent(escape(atob(b64)));
    }

    // M·ªöI: t·∫£i CSV b·∫±ng raw.githubusercontent.com (kh√¥ng decode base64)
    async function githubPullCsv() {
      // 1) L·∫•y metadata ƒë·ªÉ c√≥ SHA (ph·ª•c v·ª• cho l·∫ßn PUSH ti·∫øp theo)
      const apiUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(GH_PATH)}?ref=${GH_BRANCH}`;

      try {
        const headers = {
          'Accept': 'application/vnd.github+json'
        };
        if (githubToken) {
          headers['Authorization'] = 'Bearer ' + githubToken;
        }

        const metaRes = await fetch(apiUrl, { headers });

        if (metaRes.status === 404) {
          alert('Tr√™n GitHub ch∆∞a c√≥ file CSV (404). H√£y l∆∞u l√™n 1 l·∫ßn tr∆∞·ªõc.');
          return;
        }

        if (!metaRes.ok) {
          alert('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c metadata CSV t·ª´ GitHub. M√£ l·ªói: ' + metaRes.status);
          return;
        }

        const meta = await metaRes.json();
        lastGithubSha = meta.sha || null;
      } catch (e) {
        console.error(e);
        alert('L·ªói khi ƒë·ªçc metadata CSV t·ª´ GitHub (xem console).');
        return;
      }

      // 2) T·∫£i file CSV d·∫°ng raw text
      const rawUrl = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${GH_PATH}`;

      try {
        const res = await fetch(rawUrl, { cache: 'no-cache' });
        if (!res.ok) {
          alert('Kh√¥ng t·∫£i ƒë∆∞·ª£c CSV raw t·ª´ GitHub. M√£ l·ªói: ' + res.status);
          return;
        }

        const csvText = await res.text();
        parseCsv(csvText);
        alert('ƒê√£ t·∫£i CSV t·ª´ GitHub: ' + items.length + ' s·∫£n ph·∫©m');
      } catch (e) {
        console.error(e);
        alert('L·ªói khi t·∫£i CSV raw t·ª´ GitHub (xem console).');
      }
    }

    async function githubPushCsv() {
      if (!items.length) {
        if (!confirm('Ch∆∞a c√≥ d·ªØ li·ªáu (items tr·ªëng). V·∫´n mu·ªën l∆∞u file r·ªóng l√™n GitHub?')) {
          return;
        }
      }
      if (!(await ensureGithubToken())) return;

      const csvText = buildCsvFromItems();
      const contentB64 = toBase64Unicode(csvText || '');

      const url = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(GH_PATH)}`;
      const body = {
        message: 'Update inventory CSV from kiemkho app',
        content: contentB64,
        branch: GH_BRANCH
      };
      if (lastGithubSha) {
        body.sha = lastGithubSha;
      }

      try {
        const res = await fetch(url, {
          method: 'PUT',
          headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': 'Bearer ' + githubToken,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          if (res.status === 409) {
            alert('L·ªói 409 (conflict): File tr√™n GitHub ƒë√£ ƒë·ªïi. H√£y b·∫•m "T·∫£i CSV t·ª´ GitHub" r·ªìi l∆∞u l·∫°i.');
          } else {
            alert('Kh√¥ng l∆∞u ƒë∆∞·ª£c CSV l√™n GitHub. M√£ l·ªói: ' + res.status);
          }
          return;
        }

        const data = await res.json();
        if (data && data.content && data.content.sha) {
          lastGithubSha = data.content.sha;
        }
        console.log('ƒê√£ l∆∞u CSV l√™n GitHub (auto ho·∫∑c th·ªß c√¥ng).');
      } catch (e) {
        console.error(e);
        alert('L·ªói khi l∆∞u CSV l√™n GitHub (xem console).');
      }
    }

    // ===== Auto login b·∫±ng m√£ "tngon" + t·ª± load CSV =====
    async function initGithubAuto() {
      const code = prompt('Nh·∫≠p m√£ n·ªôi b·ªô ƒë·ªÉ d√πng GitHub sync (vd: tngon). B·∫•m H·ªßy n·∫øu ch·ªâ mu·ªën d√πng offline:');
      if (!code) return;
      if (code.trim() !== INTERNAL_CODE) {
        alert('Sai m√£ n·ªôi b·ªô.');
        return;
      }
      if (await ensureGithubToken()) {
        githubPullCsv();
      }
    }

    // ===== Camera qu√©t m√£ =====
    async function startCameraScan() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Tr√¨nh duy·ªát kh√¥ng cho d√πng camera. D√πng ƒë·∫ßu ƒë·ªçc ho·∫∑c nh·∫≠p tay gi√∫p em.');
        return;
      }
      if (!barcodeDetector) {
        alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ BarcodeDetector.\nTh·ª≠ Chrome b·∫£n m·ªõi tr√™n Android/iOS gi√∫p em.');
        return;
      }

      try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' }
        });
        cameraPreview.srcObject = cameraStream;
        cameraPreview.style.display = 'block';
        stopCameraBtn.style.display = 'inline-block';
        scanning = true;
        scanLoop();
      } catch (e) {
        console.error('getUserMedia error', e);
        alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera. Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera gi√∫p em.');
      }
    }

    function stopCameraScan() {
      scanning = false;
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      cameraPreview.srcObject = null;
      cameraPreview.style.display = 'none';
      stopCameraBtn.style.display = 'none';
    }

    async function scanLoop() {
      if (!scanning || !barcodeDetector) return;
      try {
        const barcodes = await barcodeDetector.detect(cameraPreview);
        if (barcodes.length > 0) {
          const code = barcodes[0].rawValue;
          if (code) {
            // Auto-save & auto-push GitHub cho s·∫£n ph·∫©m ƒëang s·ª≠a
            const didSave = autoSaveIfDirty();
            if (didSave) githubPushCsv();
            barcodeInput.value = code;
            if (navigator.vibrate) navigator.vibrate(80);
            stopCameraScan();
            handleBarcodeEnter();
            return;
          }
        }
      } catch (e) {
        console.error('detect error', e);
      }
      requestAnimationFrame(scanLoop);
    }

    // ===== Camera ch·ª•p ·∫£nh =====
    async function startPhotoCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Tr√¨nh duy·ªát kh√¥ng cho d√πng camera. D√πng ƒë·∫ßu ƒë·ªçc ho·∫∑c nh·∫≠p tay gi√∫p em.');
        return;
      }
      try {
        photoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' }
        });
        photoPreview.srcObject = photoStream;
        photoFrame.style.display = 'block';
        takePhotoBtn.style.display = 'inline-block';
        closePhotoBtn.style.display = 'inline-block';
      } catch (e) {
        console.error('photo getUserMedia error', e);
        alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera ƒë·ªÉ ch·ª•p ·∫£nh. Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera gi√∫p em.');
      }
    }

    function stopPhotoCamera() {
      if (photoStream) {
        photoStream.getTracks().forEach(t => t.stop());
        photoStream = null;
      }
      photoPreview.srcObject = null;
      photoFrame.style.display = 'none';
      takePhotoBtn.style.display = 'none';
      closePhotoBtn.style.display = 'none';
    }

    function takePhoto() {
      if (!photoStream || !photoPreview.videoWidth || !photoPreview.videoHeight) {
        alert('Ch∆∞a s·∫µn s√†ng ch·ª•p, ƒë·ª£i video hi·ªÉn th·ªã r·ªìi b·∫•m l·∫°i gi√∫p em.');
        return;
      }

      const srcW = photoPreview.videoWidth;
      const srcH = photoPreview.videoHeight;
      const size = 250;
      photoCanvas.width = size;
      photoCanvas.height = size;

      const ctx = photoCanvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, size, size);

      const side = Math.min(srcW, srcH);
      const sx = (srcW - side) / 2;
      const sy = (srcH - side) / 2;
      ctx.drawImage(photoPreview, sx, sy, side, side, 0, 0, size, size);

      const dataUrl = photoCanvas.toDataURL('image/jpeg', 0.7);
      const base64 = dataUrl.split(',')[1] || '';

      imageInput.value = base64;
      updateImageThumbFromInput();
      formDirty = true;
      if (navigator.vibrate) navigator.vibrate(80);
      stopPhotoCamera();
    }

    // ===== B·∫Øt chu·ªói qu√©t t·ª´ ƒë·∫ßu ƒë·ªçc (to√†n trang) =====
    document.addEventListener('keydown', (e) => {
      // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô "S·ª≠a m√£" ‚Üí b·ªè h·∫øt logic b·∫Øt ƒë·∫ßu ƒë·ªçc, ƒë·ªÉ ƒë·∫ßu ƒë·ªçc nh∆∞ b√†n ph√≠m th∆∞·ªùng
      if (editBarcodeMode) {
        return;
      }

      const now = Date.now();

      if (now - lastScanTime > SCAN_TIMEOUT) {
        scanBuffer = '';
      }
      lastScanTime = now;

      if (e.key === 'Enter') {
        if (scanBuffer.trim().length >= 4) {
          // Chu·ªói t·ª´ ƒë·∫ßu ƒë·ªçc m√£ v·∫°ch
          e.preventDefault();
          const code = scanBuffer.trim();
          scanBuffer = '';
          // Auto-save & auto-push GitHub cho s·∫£n ph·∫©m ƒëang s·ª≠a
          const didSave = autoSaveIfDirty();
          if (didSave) githubPushCsv();
          barcodeInput.value = code;
          handleBarcodeEnter();
        } else if (document.activeElement === barcodeInput) {
          e.preventDefault();
          handleBarcodeEnter();
        } else {
          scanBuffer = '';
        }
        return;
      }

      if (e.ctrlKey || e.metaKey || e.altKey) return;

      if (e.key.length === 1) {
        scanBuffer += e.key;
      }
    });

    // ===== S·ª± ki·ªán dropdown danh m·ª•c =====
    categoryInput.addEventListener('focus', () => {
      showCategoryDropdown(true);
    });

    categoryInput.addEventListener('click', () => {
      showCategoryDropdown(true);
    });

    categoryInput.addEventListener('input', () => {
      formDirty = true;
      showCategoryDropdown(false);
    });

    document.addEventListener('click', (e) => {
      if (e.target !== categoryInput && !categoryDropdown.contains(e.target)) {
        hideCategoryDropdown();
      }
    });

    // ===== ƒê√°nh d·∫•u formDirty khi s·ª≠a c√°c tr∆∞·ªùng (tr·ª´ barcode) =====
    [nameInput, imageInput, qtyInput, stockInput, priceInput, noteInput].forEach(el => {
      el.addEventListener('input', () => {
        formDirty = true;
      });
    });

    // ===== Events kh√°c =====
    saveBtn.addEventListener('click', () => upsertItemFromForm(false));
    resetBtn.addEventListener('click', resetForm);
    imageInput.addEventListener('input', updateImageThumbFromInput);

    csvFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        parseCsv(event.target.result);
      };
      reader.readAsText(file, 'utf-8');
    });

    exportBtn.addEventListener('click', exportCsv);

    githubPullBtn.addEventListener('click', githubPullCsv);
    githubPushBtn.addEventListener('click', githubPushCsv);

    cameraBtn.addEventListener('click', () => {
      if (scanning) {
        stopCameraScan();
      } else {
        stopPhotoCamera();
        startCameraScan();
      }
    });

    stopCameraBtn.addEventListener('click', stopCameraScan);

    photoBtn.addEventListener('click', () => {
      stopCameraScan();
      if (photoStream) {
        stopPhotoCamera();
      } else {
        startPhotoCamera();
      }
    });

    takePhotoBtn.addEventListener('click', takePhoto);
    closePhotoBtn.addEventListener('click', stopPhotoCamera);

    searchNameBtn.addEventListener('click', searchByName);
    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchByName();
      }
    });

    // N√∫t "S·ª≠a m√£" ‚Äì b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô editBarcodeMode
    editBarcodeModeBtn.addEventListener('click', () => {
      editBarcodeMode = !editBarcodeMode;
      if (editBarcodeMode) {
        editBarcodeModeBtn.textContent = '‚úÖ ƒêang s·ª≠a m√£ (t·∫Øt auto qu√©t)';
        editBarcodeModeBtn.style.background = '#ffe8cc';
      } else {
        editBarcodeModeBtn.textContent = '‚úèÔ∏è S·ª≠a m√£';
        editBarcodeModeBtn.style.background = '';
      }
    });

    // Kh·ªüi ƒë·ªông
    loadFromLocalStorage();
    barcodeInput.focus();
    updateImageThumbFromInput();
    initGithubAuto(); // Nh·∫≠p "tngon" + auto t·∫£i CSV t·ª´ GitHub n·∫øu c√≥
  </script>
</body>
</html>
