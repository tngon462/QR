<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Ki·ªÉm kho T-NGON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 10px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 1.2rem;
      margin-bottom: 8px;
    }
    .field {
      display: flex;
      flex-direction: column;
      margin-bottom: 8px;
    }
    .inline {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    label {
      font-size: 13px;
      margin-bottom: 2px;
    }
    input, select, button {
      padding: 8px;
      font-size: 14px;
    }
    button {
      cursor: pointer;
      margin-right: 6px;
      margin-bottom: 6px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 13px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background: #f5f5f5;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tbody tr:nth-child(even) {
      background: #fafafa;
    }
    .barcode-input {
      font-size: 16px;
      font-weight: bold;
      flex: 1;
    }
    .small {
      font-size: 12px;
      color: #666;
    }

    .camera-preview {
      display: none;
      width: 100%;
      max-height: 300px;
      border: 1px solid #ccc;
      margin-top: 6px;
      border-radius: 4px;
    }

    .photo-frame {
      display: none;
      width: 250px;
      height: 250px;
      border: 2px solid #999;
      border-radius: 4px;
      margin-top: 6px;
      overflow: hidden;
    }
    .photo-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #stopCameraBtn, #takePhotoBtn, #closePhotoBtn {
      display: none;
    }
    .img-thumb {
      display: none;
      margin-top: 4px;
      width: 120px;
      height: 120px;
      object-fit: cover;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .img-table-thumb {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 3px;
    }

    .category-wrapper {
      position: relative;
      width: 100%;
    }
    .category-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 180px;
      overflow-y: auto;
      border: 1px solid #ccc;
      background: #fff;
      z-index: 10;
      font-size: 13px;
      display: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .category-item {
      padding: 4px 6px;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .category-item:hover {
      background: #eee;
    }
    .category-item.add-new {
      font-style: italic;
    }

    .search-results {
      margin-top: 4px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px;
      max-height: 200px;
      overflow-y: auto;
      background: #fafafa;
      font-size: 12px;
    }
    .search-results table {
      width: 100%;
      border-collapse: collapse;
    }
    .search-results th,
    .search-results td {
      border: 1px solid #eee;
      padding: 2px 4px;
      text-align: left;
    }
    .search-results-title {
      font-weight: 600;
      margin-bottom: 2px;
    }
    .search-results-empty {
      font-style: italic;
      color: #666;
    }
    .search-result-row {
      cursor: pointer;
    }
    .search-result-row:hover {
      background: #e6f3ff;
    }

    .small-input-row input.short-input {
      width: 5ch;
      min-width: 5ch;
      max-width: 7ch;
      text-align: right;
    }
  </style>
</head>
<body>
  <h1>App ki·ªÉm kho</h1>

  <div class="field">
    <label>M√£ v·∫°ch:</label>
    <div class="inline">
      <input id="barcodeInput" class="barcode-input" autofocus />
      <button id="cameraBtn" type="button">üì∑ Qu√©t m√£</button>
    </div>
    <button id="editBarcodeModeBtn" type="button">‚úèÔ∏è S·ª≠a m√£</button>
    <div class="small">
   </div>
    <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
    <button id="stopCameraBtn" type="button">T·∫Øt camera qu√©t</button>
  </div>

  <div class="field">
    <label>T√™n s·∫£n ph·∫©m:</label>
    <div class="inline">
      <input id="nameInput" />
      <button id="searchNameBtn" type="button">üîç T√¨m</button>
    </div>
    <div id="searchResults" class="search-results"></div>
  </div>

  <div class="field">
    <label>·∫¢nh s·∫£n ph·∫©m:</label>
    <div class="inline">
      <input id="imageInput" placeholder="Base64 ho·∫∑c URL (s·∫Ω t·ª± chuy·ªÉn th√†nh link khi ƒë·∫©y l√™n GitHub)" />
      <button id="photoBtn" type="button">üì∏ Ch·ª•p ·∫£nh</button>
    </div>
    <div class="small">
    </div>
    <div id="photoFrame" class="photo-frame">
      <video id="photoPreview" class="photo-preview" autoplay playsinline></video>
    </div>
    <div>
      <button id="takePhotoBtn" type="button">Ch·ª•p & l∆∞u v√†o form</button>
      <button id="closePhotoBtn" type="button">ƒê√≥ng camera ·∫£nh</button>
    </div>
    <canvas id="photoCanvas" style="display:none;"></canvas>
    <img id="imageThumb" class="img-thumb" alt="·∫¢nh s·∫£n ph·∫©m" />
  </div>

  <div class="field">
    <label>Danh m·ª•c:</label>
    <div class="category-wrapper">
      <input id="categoryInput" placeholder="Ch·ªçn ho·∫∑c g√µ danh m·ª•c..." autocomplete="off" />
      <div id="categoryDropdown" class="category-dropdown"></div>
    </div>
    <div class="small"> </div>
  </div>

  <div class="field">
    <label>S·ªë l∆∞·ª£ng / T·ªìn kho / Gi√° b√°n:</label>
    <div class="inline small-input-row">
      <input id="qtyInput"   type="number" value="1" min="0" class="short-input"  placeholder="SL" />
      <input id="stockInput" type="number" min="0"        class="short-input"  placeholder="T·ªìn" />
      <input id="priceInput" type="number" min="0" step="1" class="short-input" placeholder="Gi√°" />
    </div>
  </div>

  <div class="field">
    <label>Ghi ch√∫:</label>
    <input id="noteInput" />
  </div>

  <div class="field">
    <div>
      <button id="saveBtn" type="button">L∆∞u / Th√™m m·ªõi</button>
      <button id="resetBtn" type="button">X√≥a form</button>
      <button id="deleteItemBtn" type="button">üóë X√≥a h√†ng h√≥a</button>
    </div>
  </div>

  <div class="field">
    <label>Import CSV hi·ªán c√≥ (t·ª´ file m√°y):</label>
    <input id="csvFileInput" type="file" accept=".csv" />
    <div class="small">
      CSV chu·∫©n: <b>M√£ v·∫°ch,T√™n s·∫£n ph·∫©m,·∫¢nh,Danh m·ª•c,Gi√° b√°n,S·ªë l∆∞·ª£ng,T·ªìn kho,Ghi ch√∫,C·∫≠p nh·∫≠t l√∫c</b><br>
      C·ªôt <b>·∫¢nh</b> c√≥ th·ªÉ l√† base64 (·∫£nh thu nh·ªè) ho·∫∑c URL.
    </div>
  </div>

  <div class="field">
    <div>
      <button id="exportBtn" type="button">Export CSV (t·∫£i file v·ªÅ m√°y)</button>
      <button id="githubPullBtn" type="button">‚¨á T·∫£i CSV t·ª´ GitHub</button>
      <button id="githubPushBtn" type="button">‚¨Ü L∆∞u CSV l√™n GitHub (k√®m upload ·∫£nh)</button>
    </div>
    <div class="small">
      L·∫ßn ƒë·∫ßu d√πng GitHub s·∫Ω h·ªèi token (PAT) ‚Üí l∆∞u tr√™n thi·∫øt b·ªã (localStorage).<br>
      D·ªØ li·ªáu c≈©ng ƒë∆∞·ª£c l∆∞u t·∫°m trong tr√¨nh duy·ªát (localStorage) nh∆∞ tr∆∞·ªõc.
    </div>
  </div>

  <table>
    <thead>
      <tr>
        <th>#</th>
        <th>M√£ v·∫°ch</th>
        <th>T√™n s·∫£n ph·∫©m</th>
        <th>·∫¢nh</th>
        <th>Danh m·ª•c</th>
        <th>Gi√° b√°n</th>
        <th>S·ªë l∆∞·ª£ng</th>
        <th>T·ªìn kho</th>
        <th>Ghi ch√∫</th>
        <th>C·∫≠p nh·∫≠t l√∫c</th>
      </tr>
    </thead>
    <tbody id="itemsBody"></tbody>
  </table>

  <script>
    const barcodeInput   = document.getElementById('barcodeInput');
    const nameInput      = document.getElementById('nameInput');
    const imageInput     = document.getElementById('imageInput');
    const categoryInput  = document.getElementById('categoryInput');
    const qtyInput       = document.getElementById('qtyInput');
    const stockInput     = document.getElementById('stockInput');
    const priceInput     = document.getElementById('priceInput');
    const noteInput      = document.getElementById('noteInput');
    const saveBtn        = document.getElementById('saveBtn');
    const resetBtn       = document.getElementById('resetBtn');
    const deleteItemBtn  = document.getElementById('deleteItemBtn');
    const csvFileInput   = document.getElementById('csvFileInput');
    const exportBtn      = document.getElementById('exportBtn');
    const itemsBody      = document.getElementById('itemsBody');

    const cameraBtn      = document.getElementById('cameraBtn');
    const cameraPreview  = document.getElementById('cameraPreview');
    const stopCameraBtn  = document.getElementById('stopCameraBtn');

    const photoBtn       = document.getElementById('photoBtn');
    const photoFrame     = document.getElementById('photoFrame');
    const photoPreview   = document.getElementById('photoPreview');
    const takePhotoBtn   = document.getElementById('takePhotoBtn');
    const closePhotoBtn  = document.getElementById('closePhotoBtn');
    const photoCanvas    = document.getElementById('photoCanvas');
    const imageThumb     = document.getElementById('imageThumb');

    const categoryDropdown = document.getElementById('categoryDropdown');

    const githubPullBtn  = document.getElementById('githubPullBtn');
    const githubPushBtn  = document.getElementById('githubPushBtn');

    const searchNameBtn  = document.getElementById('searchNameBtn');
    const searchResults  = document.getElementById('searchResults');

    const editBarcodeModeBtn = document.getElementById('editBarcodeModeBtn');

    let items = [];
    let categoryOptions = [];
    let formDirty = false;
    let editBarcodeMode = false;

    const GH_OWNER        = 'tngon462';
    const GH_REPO         = 'QR';
    const GH_BRANCH       = 'main';
    const GH_PATH         = 'kiemkho-data.csv';
    const GH_IMAGE_FOLDER = 'kiemkho-images';

    const INTERNAL_CODE = 'tngon';

    let githubToken = localStorage.getItem('kiemkho_github_token') || '';
    let lastGithubSha = null;

    async function ensureGithubToken() {
      if (!githubToken) {
        const t = prompt('Nh·∫≠p GitHub Personal Access Token (PAT) ƒë·ªÉ ƒë·ªìng b·ªô CSV / ·∫£nh v·ªõi repo QR:');
        if (!t) return false;
        githubToken = t.trim();
        localStorage.setItem('kiemkho_github_token', githubToken);
      }
      return true;
    }

    let cameraStream = null;
    let scanning = false;
    let barcodeDetector = null;
    if ('BarcodeDetector' in window) {
      try {
        barcodeDetector = new BarcodeDetector({
          formats: ['ean_13', 'ean_8', 'code_128', 'code_39', 'upc_a', 'upc_e', 'qr_code']
        });
      } catch (e) {
        console.warn('BarcodeDetector init error', e);
        barcodeDetector = null;
      }
    }

    let photoStream = null;

    let scanBuffer = '';
    let lastScanTime = 0;
    const SCAN_TIMEOUT = 300;

    function loadFromLocalStorage() {
      const raw = localStorage.getItem('inventoryItems_v5');
      if (!raw) return;
      try {
        items = JSON.parse(raw);
        renderTable();
        rebuildCategoryList();
      } catch (e) {
        console.error('LS parse error', e);
      }
    }

    function saveToLocalStorage() {
      localStorage.setItem('inventoryItems_v5', JSON.stringify(items));
    }

    function nowString() {
      const d = new Date();
      const pad = (n) => (n < 10 ? '0' + n : n);
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} `
           + `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function normalizeStr(str) {
      return (str || '')
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/ƒë/g, 'd')
        .replace(/[^0-9a-z\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function isProbablyBase64(str) {
      return /^[A-Za-z0-9+/=]+$/.test(str) && str.length > 100;
    }

    function makeImageSrc(imageValue) {
      if (!imageValue) return null;
      const v = imageValue.trim();
      if (!v) return null;
      if (v.startsWith('http') || v.startsWith('data:')) {
        return v;
      }
      if (isProbablyBase64(v)) {
        return 'data:image/jpeg;base64,' + v;
      }
      return null;
    }

    function updateImageThumbFromInput() {
      const src = makeImageSrc(imageInput.value || '');
      if (src) {
        imageThumb.src = src;
        imageThumb.style.display = 'block';
      } else {
        imageThumb.src = '';
        imageThumb.style.display = 'none';
      }
    }

    function truncate(str, maxLen) {
      if (str === null || str === undefined) return '';
      str = String(str);
      if (str.length <= maxLen) return str;
      if (maxLen <= 1) return str.slice(0, maxLen);
      return str.slice(0, maxLen - 1) + '‚Ä¶';
    }

    function renderTable() {
      itemsBody.innerHTML = '';
      items.forEach((item, idx) => {
        const tr = document.createElement('tr');
        tr.dataset.barcode = item.barcode || '';

        const imgSrc = makeImageSrc(item.image || '');
        let imgCell = '';
        if (imgSrc) {
          imgCell = `<img src="${imgSrc}" class="img-table-thumb" alt="·∫¢nh" />`;
        } else if (item.image) {
          imgCell = item.image;
        }

        const barcodeTxt = truncate(item.barcode || '', 15);
        const nameTxt    = truncate(item.name || '', 15);
        const catTxt     = truncate(item.category || '', 20);

        const priceFull  = (item.price !== '' && item.price != null) ? String(item.price) : '';
        const priceTxt   = truncate(priceFull, 4);

        const qtyFull    = (item.qty !== '' && item.qty != null) ? String(item.qty) : '';
        const qtyTxt     = truncate(qtyFull, 3);

        const stockFull  = (item.stock !== '' && item.stock != null) ? String(item.stock) : '';
        const stockTxt   = truncate(stockFull, 4);

        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td title="${item.barcode || ''}">${barcodeTxt}</td>
          <td title="${item.name || ''}">${nameTxt}</td>
          <td>${imgCell}</td>
          <td title="${item.category || ''}">${catTxt}</td>
          <td title="${priceFull}">${priceTxt}</td>
          <td title="${qtyFull}">${qtyTxt}</td>
          <td title="${stockFull}">${stockTxt}</td>
          <td>${item.note || ''}</td>
          <td>${item.updated_at || ''}</td>
        `;

        tr.addEventListener('click', () => {
          loadItemToForm(item);
          barcodeInput.focus();
          barcodeInput.select();
        });

        itemsBody.appendChild(tr);
      });
    }

    function clearSearchResults() {
      searchResults.innerHTML = '';
    }

    function loadItemToForm(item) {
      barcodeInput.value  = item.barcode || '';
      nameInput.value     = item.name || '';
      imageInput.value    = item.image || '';
      categoryInput.value = item.category || '';
      qtyInput.value      = item.qty ?? 0;
      stockInput.value    = item.stock ?? '';
      priceInput.value    = (item.price !== '' && item.price != null) ? item.price : '';
      noteInput.value     = item.note || '';
      updateImageThumbFromInput();
      formDirty = false;
      clearSearchResults();
    }

    function resetForm() {
      barcodeInput.value  = '';
      nameInput.value     = '';
      imageInput.value    = '';
      categoryInput.value = '';
      qtyInput.value      = '1';
      stockInput.value    = '';
      priceInput.value    = '';
      noteInput.value     = '';
      updateImageThumbFromInput();
      formDirty = false;
      clearSearchResults();
      barcodeInput.focus();
    }

    function upsertItemFromForm(auto = false) {
      const barcode  = (barcodeInput.value || '').trim();
      const name     = (nameInput.value || '').trim();
      const image    = (imageInput.value || '').trim();
      const category = (categoryInput.value || '').trim();
      const priceRaw = (priceInput.value || '').trim();

      let missing = [];
      if (!barcode)  missing.push('m√£ v·∫°ch');
      if (!name)     missing.push('t√™n s·∫£n ph·∫©m');
      if (!category) missing.push('danh m·ª•c');
      if (!priceRaw) missing.push('gi√° b√°n');

      let qty   = parseInt(qtyInput.value, 10);
      if (isNaN(qty)) qty = 0;
      let stock = parseInt(stockInput.value, 10);
      if (isNaN(stock)) stock = '';
      let price = '';
      if (priceRaw !== '') {
        const p = parseFloat(priceRaw);
        price = isNaN(p) ? '' : p;
      }

      const note = (noteInput.value || '').trim();

      if (missing.length > 0) {
        if (!auto) {
          alert('Thi·∫øu: ' + missing.join(', '));
          const first = missing[0];
          if (first === 'm√£ v·∫°ch') barcodeInput.focus();
          else if (first === 't√™n s·∫£n ph·∫©m') nameInput.focus();
          else if (first === 'danh m·ª•c') categoryInput.focus();
          else if (first === 'gi√° b√°n') priceInput.focus();
        }
        return false;
      }

      let existing = items.find((i) => i.barcode === barcode);

      if (existing) {
        existing.name       = name;
        existing.image      = image;
        existing.category   = category;
        existing.price      = price;
        existing.qty        = qty;
        existing.stock      = stock;
        existing.note       = note;
        existing.updated_at = nowString();
      } else {
        existing = {
          barcode,
          name,
          image,
          category,
          price,
          qty,
          stock,
          note,
          updated_at: nowString(),
        };
        items.push(existing);
      }

      saveToLocalStorage();
      rebuildCategoryList();
      renderTable();
      formDirty = false;
      return true;
    }

    function autoSaveIfDirty() {
      const currentBarcode = (barcodeInput.value || '').trim();
      if (!currentBarcode) return false;
      if (!formDirty) return false;
      return !!upsertItemFromForm(true);
    }

    function showSearchResults(results, type, keyword) {
      searchResults.innerHTML = '';

      if (!results || !results.length) {
        const div = document.createElement('div');
        div.className = 'search-results-empty';
        div.textContent = 'Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ph√π h·ª£p.';
        searchResults.appendChild(div);
        return;
      }

      const title = document.createElement('div');
      title.className = 'search-results-title';
      if (type === 'name') {
        title.textContent = `K·∫øt qu·∫£ t√¨m theo t√™n "${keyword}":`;
      } else if (type === 'barcode-partial') {
        title.textContent = `M√£ v·∫°ch g·∫ßn ƒë√∫ng "${keyword}" ‚Äì ch·ªçn 1 d√≤ng:`;
      } else if (type === 'barcode-exact') {
        title.textContent = `C√≥ nhi·ªÅu m√£ tr√πng "${keyword}" ‚Äì ch·ªçn 1 d√≤ng:`;
      } else {
        title.textContent = 'K·∫øt qu·∫£ t√¨m ki·∫øm:';
      }
      searchResults.appendChild(title);

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>M√£ v·∫°ch</th><th>T√™n</th><th>Danh m·ª•c</th></tr>';
      table.appendChild(thead);
      const tbody = document.createElement('tbody');

      results.forEach((item) => {
        const tr = document.createElement('tr');
        tr.className = 'search-result-row';
        tr.innerHTML = `
          <td>${item.barcode || ''}</td>
          <td>${item.name || ''}</td>
          <td>${item.category || ''}</td>
        `;
        tr.addEventListener('click', () => {
          loadItemToForm(item);
          barcodeInput.value = item.barcode || '';
          barcodeInput.focus();
          barcodeInput.select();
          clearSearchResults();
        });
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      searchResults.appendChild(table);
    }

    function searchByName() {
      const keyword = (nameInput.value || '').trim();
      if (!keyword) {
        alert('Nh·∫≠p t√™n s·∫£n ph·∫©m c·∫ßn t√¨m');
        nameInput.focus();
        return;
      }
      const kwNorm = normalizeStr(keyword);
      const results = items.filter((item) => {
        const nameNorm = normalizeStr(item.name || '');
        return nameNorm.includes(kwNorm);
      });
      showSearchResults(results, 'name', keyword);
    }

    function handleBarcodeEnter() {
      clearSearchResults();
      const barcode = (barcodeInput.value || '').trim();
      if (!barcode) return;

      const exactMatches = items.filter(i => i.barcode === barcode);
      if (exactMatches.length === 1) {
        loadItemToForm(exactMatches[0]);
        return;
      }
      if (exactMatches.length > 1) {
        showSearchResults(exactMatches, 'barcode-exact', barcode);
        return;
      }

      const partialMatches = items.filter(i =>
        i.barcode && i.barcode.includes(barcode)
      );
      if (partialMatches.length === 1) {
        loadItemToForm(partialMatches[0]);
        return;
      }
      if (partialMatches.length > 1) {
        showSearchResults(partialMatches, 'barcode-partial', barcode);
        return;
      }

      nameInput.value     = '';
      imageInput.value    = '';
      categoryInput.value = '';
      qtyInput.value      = '1';
      stockInput.value    = '';
      priceInput.value    = '';
      noteInput.value     = '';
      updateImageThumbFromInput();
      formDirty = false;
    }

    // g·ª° c√°c case "Danh m·ª•c,,Gi√°,,SL,,T·ªìn"
    function repairWeirdPackedFields(item) {
      if (item.category && item.category.indexOf(',,') >= 0) {
        let raw = item.category.trim();
        raw = raw.replace(/^"+|"+$/g, '');
        if (raw.indexOf(',,') >= 0) {
          const parts = raw.split(',,');
          if (parts[0]) {
            item.category = parts[0];
          }
          if ((item.price === '' || item.price == null) && parts[1] && !isNaN(parseFloat(parts[1]))) {
            item.price = parseFloat(parts[1]);
          }
          if ((item.qty == null || item.qty === 0) && parts[2] && !isNaN(parseInt(parts[2], 10))) {
            item.qty = parseInt(parts[2], 10);
          }
          if ((item.stock == null || item.stock === '' || item.stock === 0) && parts[3] && !isNaN(parseInt(parts[3], 10))) {
            item.stock = parseInt(parts[3], 10);
          }
        }
      }
      if (item.category) item.category = item.category.replace(/^"+|"+$/g, '');
      if (item.name) item.name = item.name.replace(/^"+|"+$/g, '');
      if (item.note) item.note = item.note.replace(/^"+|"+$/g, '');
    }

    // === CSV helpers ===
    function splitCsvLine(line) {
      const cols = [];
      let cur = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const ch = line[i];

        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') {
            cur += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === ',' && !inQuotes) {
          cols.push(cur);
          cur = '';
        } else {
          cur += ch;
        }
      }
      cols.push(cur);
      return cols;
    }

    function parseCsv(text) {
      if (!text) {
        alert('File CSV tr·ªëng ho·∫∑c kh√¥ng ƒë·ªçc ƒë∆∞·ª£c.');
        return;
      }

      const lines = text.split(/\r?\n/);
      console.log('parseCsv: lines =', lines.length);
      if (lines.length <= 1) {
        alert('File CSV ch·ªâ c√≥ header ho·∫∑c kh√¥ng c√≥ d·ªØ li·ªáu.');
        return;
      }

      items = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line || !line.trim()) continue;

        const cols = splitCsvLine(line);
        const getCol = (idx) => (idx >= 0 && idx < cols.length ? cols[idx] : '');

        // Chu·∫©n file: 0..8 ƒë√∫ng nh∆∞ kiemkho-data.csv hi·ªán t·∫°i
        const rawBarcode = getCol(0);
        const barcode = (rawBarcode || '').replace(/^"+|"+$/g, '').trim();
        if (!barcode) continue;

        const name       = (getCol(1) || '').replace(/^"+|"+$/g, '');
        const image      = (getCol(2) || '').replace(/^"+|"+$/g, '');
        let   category   = (getCol(3) || '').replace(/^"+|"+$/g, '');

        const priceStr   = (getCol(4) || '').replace(/^"+|"+$/g, '').trim();
        let   price      = '';
        if (priceStr) {
          const p = parseFloat(priceStr);
          if (!isNaN(p)) price = p;
        }

        const qtyStr     = (getCol(5) || '').replace(/^"+|"+$/g, '').trim();
        let   qty        = 0;
        if (qtyStr) {
          const q = parseInt(qtyStr, 10);
          if (!isNaN(q)) qty = q;
        }

        const stockStr   = (getCol(6) || '').replace(/^"+|"+$/g, '').trim();
        let   stock      = '';
        if (stockStr) {
          const s = parseInt(stockStr, 10);
          if (!isNaN(s)) stock = s;
        }

        const note       = (getCol(7) || '').replace(/^"+|"+$/g, '');
        const updated_at = (getCol(8) || '').replace(/^"+|"+$/g, '');

        const item = {
          barcode,
          name,
          image,
          category,
          price,
          qty,
          stock,
          note,
          updated_at,
        };

        repairWeirdPackedFields(item);
        items.push(item);
      }

      saveToLocalStorage();
      rebuildCategoryList();
      renderTable();
      formDirty = false;
      clearSearchResults();

      alert('ƒê√£ t·∫£i CSV: ' + items.length + ' s·∫£n ph·∫©m');
    }

    function buildCsvFromItems() {
      if (!items.length) return '';
      const header = 'M√£ v·∫°ch,T√™n s·∫£n ph·∫©m,·∫¢nh,Danh m·ª•c,Gi√° b√°n,S·ªë l∆∞·ª£ng,T·ªìn kho,Ghi ch√∫,C·∫≠p nh·∫≠t l√∫c';
      const lines = [header];

      items.forEach((item) => {
        const row = [
          item.barcode || '',
          (item.name || '').replace(/,/g, ' '),
          (item.image || ''),
          (item.category || '').replace(/,/g, ' '),
          (item.price !== '' && item.price != null ? item.price : ''),
          item.qty ?? 0,
          (item.stock !== '' && item.stock != null ? item.stock : ''),
          (item.note || '').replace(/,/g, ' '),
          item.updated_at || '',
        ];
        lines.push(row.join(','));
      });

      return lines.join('\n');
    }

    function exportCsv() {
      if (!items.length) {
        alert('Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ export');
        return;
      }
      const csvText = buildCsvFromItems();
      const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'hang-kiem-kho.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function rebuildCategoryList() {
      const set = new Set();
      items.forEach((item) => {
        if (item.category && item.category.trim()) {
          set.add(item.category.trim());
        }
      });
      categoryOptions = Array.from(set).sort();
      buildCategoryDropdown('');
    }

    function buildCategoryDropdown(filterText = '') {
      categoryDropdown.innerHTML = '';

      const ft = (filterText || '').trim().toLowerCase();
      let filtered = categoryOptions;
      if (ft) {
        filtered = categoryOptions.filter(cat =>
          cat.toLowerCase().includes(ft)
        );
      }

      filtered.forEach((cat) => {
        const div = document.createElement('div');
        div.className = 'category-item';
        div.textContent = cat;
        div.title = cat;
        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
          categoryInput.value = cat;
          hideCategoryDropdown();
          formDirty = true;
        });
        categoryDropdown.appendChild(div);
      });

      const addNew = document.createElement('div');
      addNew.className = 'category-item add-new';
      addNew.textContent = 'Ôºã Th√™m danh m·ª•c m·ªõi‚Ä¶';
      addNew.addEventListener('mousedown', (e) => {
        e.preventDefault();
        const name = prompt('Nh·∫≠p t√™n danh m·ª•c m·ªõi:');
        if (name) {
          const trimmed = name.trim();
          if (trimmed) {
            categoryInput.value = trimmed;
            if (!categoryOptions.includes(trimmed)) {
              categoryOptions.push(trimmed);
              categoryOptions.sort();
            }
            formDirty = true;
          }
        }
        hideCategoryDropdown();
      });
      categoryDropdown.appendChild(addNew);
    }

    function showCategoryDropdown(showAll = false) {
      const filter = showAll ? '' : categoryInput.value;
      buildCategoryDropdown(filter);
      if (categoryOptions.length || categoryDropdown.children.length) {
        categoryDropdown.style.display = 'block';
      }
    }

    function hideCategoryDropdown() {
      categoryDropdown.style.display = 'none';
    }

    function toBase64Unicode(str) {
      return btoa(unescape(encodeURIComponent(str)));
    }

    function fromBase64Unicode(b64) {
      return decodeURIComponent(escape(atob(b64)));
    }

    function encodeGithubPath(path) {
      return path.split('/').map(encodeURIComponent).join('/');
    }

   async function githubPullCsv() {
  if (!(await ensureGithubToken())) return;

  const apiUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(GH_PATH)}?ref=${GH_BRANCH}`;
  const rawUrl = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${GH_PATH}`;

  try {
    const res = await fetch(apiUrl, {
      headers: {
        'Accept': 'application/vnd.github+json',
        'Authorization': 'Bearer ' + githubToken
      }
    });

    if (res.status === 404) {
      alert('Tr√™n GitHub ch∆∞a c√≥ file CSV (404). H√£y l∆∞u l√™n 1 l·∫ßn tr∆∞·ªõc.');
      return;
    }

    if (!res.ok) {
      alert('Kh√¥ng t·∫£i ƒë∆∞·ª£c CSV t·ª´ GitHub (API). M√£ l·ªói: ' + res.status);
      return;
    }

    const data = await res.json();
    lastGithubSha = data.sha || null;

    let csvText = '';

    // 1. Th·ª≠ decode t·ª´ API (base64)
    if (data.content) {
      try {
        const contentB64 = (data.content || '').replace(/\n/g, '');
        csvText = fromBase64Unicode(contentB64);
      } catch (e) {
        console.error('Decode CSV t·ª´ API th·∫•t b·∫°i, s·∫Ω fallback raw URL', e);
        csvText = '';
      }
    }

    // 2. N·∫øu v·∫´n r·ªóng ‚Üí fallback sang raw.githubusercontent.com
    if (!csvText) {
      console.warn('API tr·∫£ v·ªÅ CSV r·ªóng ho·∫∑c kh√¥ng decode ƒë∆∞·ª£c, fallback raw URL');
      const rawRes = await fetch(rawUrl);
      if (!rawRes.ok) {
        alert('Kh√¥ng t·∫£i ƒë∆∞·ª£c CSV t·ª´ raw.githubusercontent.com. M√£ l·ªói: ' + rawRes.status);
        return;
      }
      csvText = await rawRes.text();
    }

    parseCsv(csvText);
  } catch (e) {
    console.error(e);
    alert('L·ªói khi t·∫£i CSV t·ª´ GitHub (xem console).');
  }
}

   async function uploadImageBase64ToGithub(barcode, base64Data) {
  if (!githubToken) return null;
  if (!barcode) return null;
  if (!base64Data) return null;

  const filename = `${GH_IMAGE_FOLDER}/${barcode}.jpg`;
  const apiUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeGithubPath(filename)}`;

  // 1. Ki·ªÉm tra xem file ƒë√£ t·ªìn t·∫°i tr√™n GitHub ch∆∞a
  try {
    const checkRes = await fetch(apiUrl + `?ref=${GH_BRANCH}`, {
      headers: {
        'Accept': 'application/vnd.github+json',
        'Authorization': 'Bearer ' + githubToken
      }
    });

    if (checkRes.ok) {
      // ƒê√É T·ªíN T·∫†I ‚Üí d√πng l·∫°i link c≈©, kh·ªèi PUT n·ªØa ƒë·ªÉ tr√°nh l·ªói 422
      const meta = await checkRes.json();
      if (meta && meta.download_url) {
        console.log('·∫¢nh ƒë√£ t·ªìn t·∫°i tr√™n GitHub, d√πng l·∫°i:', barcode, meta.download_url);
        return meta.download_url;
      }
      // N·∫øu v√¨ l√Ω do g√¨ kh√¥ng c√≥ download_url ‚Üí t·ª± build link raw
      const fallbackUrl = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${filename}`;
      console.log('·∫¢nh ƒë√£ t·ªìn t·∫°i, d√πng link raw fallback:', barcode, fallbackUrl);
      return fallbackUrl;
    } else if (checkRes.status !== 404) {
      console.warn('Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c file ·∫£nh (status ' + checkRes.status + '), v·∫´n th·ª≠ upload m·ªõi.');
    }
    // N·∫øu 404 th√¨ ti·∫øp t·ª•c xu·ªëng d∆∞·ªõi ƒë·ªÉ t·∫°o file m·ªõi
  } catch (e) {
    console.warn('L·ªói khi ki·ªÉm tra file ·∫£nh tr∆∞·ªõc khi upload', e);
  }

  // 2. File ch∆∞a c√≥ ‚Üí t·∫°o m·ªõi b·∫±ng PUT
  const body = {
    message: `Add product image ${barcode}`,
    content: base64Data,
    branch: GH_BRANCH
  };

  const res = await fetch(apiUrl, {
    method: 'PUT',
    headers: {
      'Accept': 'application/vnd.github+json',
      'Authorization': 'Bearer ' + githubToken,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const text = await res.text();
    console.error('L·ªói upload ·∫£nh GitHub:', res.status, text);
    throw new Error('Upload ·∫£nh th·∫•t b·∫°i: ' + res.status);
  }

  const json = await res.json();
  const publicUrl = json.content && json.content.download_url;
  const finalUrl = publicUrl || `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${filename}`;
  console.log('Upload ·∫£nh OK (t·∫°o m·ªõi):', barcode, finalUrl);
  return finalUrl;
}

    async function uploadImagesForItemsIfNeeded() {
      let uploadedCount = 0;

      for (const item of items) {
        let raw = (item.image || '').trim();
        if (!raw) continue;

        if (/^https?:\/\//i.test(raw)) continue;

        raw = raw.replace(/^"+|"+$/g, '');
        raw = raw.replace(/^data:image\/[a-zA-Z0-9+.\-]+;base64,/, '');
        raw = raw.trim();

        if (!isProbablyBase64(raw)) continue;

        const barcode = item.barcode || '';
        if (!barcode) continue;

        try {
          const url = await uploadImageBase64ToGithub(barcode, raw);
          if (url) {
            item.image = url;
            uploadedCount++;
          }
        } catch (e) {
          console.error('Upload ·∫£nh th·∫•t b·∫°i cho', barcode, e);
        }
      }

      if (uploadedCount > 0) {
        saveToLocalStorage();
        renderTable();
        alert(`ƒê√£ upload ${uploadedCount} ·∫£nh l√™n GitHub & chuy·ªÉn th√†nh link.`);
      }
    }

    async function githubPushCsv() {
      if (!items.length) {
        if (!confirm('Ch∆∞a c√≥ d·ªØ li·ªáu (items tr·ªëng). V·∫´n mu·ªën l∆∞u file r·ªóng l√™n GitHub?')) {
          return;
        }
      }
      if (!(await ensureGithubToken())) return;

      await uploadImagesForItemsIfNeeded();

      const csvText = buildCsvFromItems();
      const contentB64 = toBase64Unicode(csvText || '');

      const url = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeURIComponent(GH_PATH)}`;
      const body = {
        message: 'Update inventory CSV from kiemkho app',
        content: contentB64,
        branch: GH_BRANCH
      };
      if (lastGithubSha) {
        body.sha = lastGithubSha;
      }

      try {
        const res = await fetch(url, {
          method: 'PUT',
          headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': 'Bearer ' + githubToken,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          if (res.status === 409) {
            alert('L·ªói 409 (conflict): File tr√™n GitHub ƒë√£ ƒë·ªïi. H√£y b·∫•m "T·∫£i CSV t·ª´ GitHub" r·ªìi l∆∞u l·∫°i.');
          } else {
            alert('Kh√¥ng l∆∞u ƒë∆∞·ª£c CSV l√™n GitHub. M√£ l·ªói: ' + res.status);
          }
          return;
        }

        const data = await res.json();
        if (data && data.content && data.content.sha) {
          lastGithubSha = data.content.sha;
        }
        alert('ƒê√£ l∆∞u CSV (v√† link ·∫£nh) l√™n GitHub xong.');
      } catch (e) {
        console.error(e);
        alert('L·ªói khi l∆∞u CSV l√™n GitHub (xem console).');
      }
    }

    async function deleteGithubImageIfFromThisRepo(imageUrl, barcode) {
      if (!githubToken) return;
      if (!imageUrl) return;

      try {
        const u = new URL(imageUrl);
        if (u.hostname !== 'raw.githubusercontent.com') return;

        const segments = u.pathname.split('/').filter(Boolean);
        if (segments.length < 4) return;
        const owner  = segments[0];
        const repo   = segments[1];
        const branch = segments[2];
        const pathSegments = segments.slice(3);
        if (owner !== GH_OWNER || repo !== GH_REPO) return;
        const path = pathSegments.join('/');

        const metaUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeGithubPath(path)}?ref=${branch}`;
        const metaRes = await fetch(metaUrl, {
          headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': 'Bearer ' + githubToken
          }
        });
        if (metaRes.status === 404) return;
        if (!metaRes.ok) {
          console.error('Kh√¥ng l·∫•y ƒë∆∞·ª£c metadata ·∫£nh ƒë·ªÉ x√≥a', metaRes.status);
          return;
        }
        const meta = await metaRes.json();
        const sha = meta.sha;
        if (!sha) return;

        const delUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encodeGithubPath(path)}`;
        const body = {
          message: `Delete product image for ${barcode}`,
          sha: sha,
          branch: branch
        };
        const delRes = await fetch(delUrl, {
          method: 'DELETE',
          headers: {
            'Accept': 'application/vnd.github+json',
            'Authorization': 'Bearer ' + githubToken,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });
        if (!delRes.ok) {
          console.error('X√≥a ·∫£nh GitHub th·∫•t b·∫°i:', delRes.status);
        } else {
          console.log('ƒê√£ x√≥a ·∫£nh tr√™n GitHub cho', barcode);
        }
      } catch (e) {
        console.error('L·ªói khi x√≥a ·∫£nh GitHub:', e);
      }
    }

    async function deleteCurrentItem() {
      const barcode = (barcodeInput.value || '').trim();
      if (!barcode) {
        alert('Ch∆∞a c√≥ m√£ v·∫°ch ƒë·ªÉ x√≥a.');
        return;
      }
      const idx = items.findIndex(i => i.barcode === barcode);
      if (idx === -1) {
        alert('Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m c√≥ m√£ n√†y trong danh s√°ch.');
        return;
      }
      const item = items[idx];
      const name = item.name || '';

      if (!confirm(`X√≥a s·∫£n ph·∫©m "${name}" (m√£: ${barcode})?\n·∫¢nh tr√™n GitHub (n·∫øu c√≥) c≈©ng s·∫Ω ƒë∆∞·ª£c x√≥a.`)) {
        return;
      }

      const imgVal = (item.image || '').trim();
      if (imgVal && imgVal.startsWith('http') && githubToken) {
        await deleteGithubImageIfFromThisRepo(imgVal, barcode);
      }

      items.splice(idx, 1);
      saveToLocalStorage();
      renderTable();
      resetForm();

      if (githubToken) {
        githubPushCsv();
      }
    }

    async function initGithubAuto() {
      const code = prompt('Nh·∫≠p m√£ n·ªôi b·ªô ƒë·ªÉ d√πng GitHub sync (vd: tngon). B·∫•m H·ªßy n·∫øu ch·ªâ mu·ªën d√πng offline:');
      if (!code) return;
      if (code.trim() !== INTERNAL_CODE) {
        alert('Sai m√£ n·ªôi b·ªô.');
        return;
      }
      if (await ensureGithubToken()) {
        githubPullCsv();
      }
    }

    async function startCameraScan() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Tr√¨nh duy·ªát kh√¥ng cho d√πng camera. D√πng ƒë·∫ßu ƒë·ªçc ho·∫∑c nh·∫≠p tay gi√∫p em.');
        return;
      }
      if (!barcodeDetector) {
        alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ BarcodeDetector.\nTh·ª≠ Chrome b·∫£n m·ªõi tr√™n Android/iOS gi√∫p em.');
        return;
      }

      try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' }
        });
        cameraPreview.srcObject = cameraStream;
        cameraPreview.style.display = 'block';
        stopCameraBtn.style.display = 'inline-block';
        scanning = true;
        scanLoop();
      } catch (e) {
        console.error('getUserMedia error', e);
        alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera. Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera gi√∫p em.');
      }
    }

    function stopCameraScan() {
      scanning = false;
      if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
      }
      cameraPreview.srcObject = null;
      cameraPreview.style.display = 'none';
      stopCameraBtn.style.display = 'none';
    }

    async function scanLoop() {
      if (!scanning || !barcodeDetector) return;
      try {
        const barcodes = await barcodeDetector.detect(cameraPreview);
        if (barcodes.length > 0) {
          const code = barcodes[0].rawValue;
          if (code) {
            const didSave = autoSaveIfDirty();
            if (didSave) githubPushCsv();
            barcodeInput.value = code;
            if (navigator.vibrate) navigator.vibrate(80);
            stopCameraScan();
            handleBarcodeEnter();
            return;
          }
        }
      } catch (e) {
        console.error('detect error', e);
      }
      requestAnimationFrame(scanLoop);
    }

    async function startPhotoCamera() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Tr√¨nh duy·ªát kh√¥ng cho d√πng camera. D√πng ƒë·∫ßu ƒë·ªçc ho·∫∑c nh·∫≠p tay gi√∫p em.');
        return;
      }
      try {
        photoStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' }
        });
        photoPreview.srcObject = photoStream;
        photoFrame.style.display = 'block';
        takePhotoBtn.style.display = 'inline-block';
        closePhotoBtn.style.display = 'inline-block';
      } catch (e) {
        console.error('photo getUserMedia error', e);
        alert('Kh√¥ng m·ªü ƒë∆∞·ª£c camera ƒë·ªÉ ch·ª•p ·∫£nh. Ki·ªÉm tra quy·ªÅn truy c·∫≠p camera gi√∫p em.');
      }
    }

    function stopPhotoCamera() {
      if (photoStream) {
        photoStream.getTracks().forEach(t => t.stop());
        photoStream = null;
      }
      photoPreview.srcObject = null;
      photoFrame.style.display = 'none';
      takePhotoBtn.style.display = 'none';
      closePhotoBtn.style.display = 'none';
    }

    function takePhoto() {
      if (!photoStream || !photoPreview.videoWidth || !photoPreview.videoHeight) {
        alert('Ch∆∞a s·∫µn s√†ng ch·ª•p, ƒë·ª£i video hi·ªÉn th·ªã r·ªìi b·∫•m l·∫°i gi√∫p em.');
        return;
      }

      const srcW = photoPreview.videoWidth;
      const srcH = photoPreview.videoHeight;
      const size = 250;
      photoCanvas.width = size;
      photoCanvas.height = size;

      const ctx = photoCanvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, size, size);

      const side = Math.min(srcW, srcH);
      const sx = (srcW - side) / 2;
      const sy = (srcH - side) / 2;
      ctx.drawImage(photoPreview, sx, sy, side, side, 0, 0, size, size);

      const dataUrl = photoCanvas.toDataURL('image/jpeg', 0.7);
      const base64 = dataUrl.split(',')[1] || '';

      imageInput.value = base64;
      updateImageThumbFromInput();
      formDirty = true;
      if (navigator.vibrate) navigator.vibrate(80);
      stopPhotoCamera();
    }

    document.addEventListener('keydown', (e) => {
      if (editBarcodeMode) {
        return;
      }

      const now = Date.now();

      if (now - lastScanTime > SCAN_TIMEOUT) {
        scanBuffer = '';
      }
      lastScanTime = now;

      if (e.key === 'Enter') {
        if (scanBuffer.trim().length >= 4) {
          e.preventDefault();
          const code = scanBuffer.trim();
          scanBuffer = '';
          const didSave = autoSaveIfDirty();
          if (didSave) githubPushCsv();
          barcodeInput.value = code;
          handleBarcodeEnter();
        } else if (document.activeElement === barcodeInput) {
          e.preventDefault();
          handleBarcodeEnter();
        } else {
          scanBuffer = '';
        }
        return;
      }

      if (e.ctrlKey || e.metaKey || e.altKey) return;

      if (e.key.length === 1) {
        scanBuffer += e.key;
      }
    });

    categoryInput.addEventListener('focus', () => {
      showCategoryDropdown(true);
    });

    categoryInput.addEventListener('click', () => {
      showCategoryDropdown(true);
    });

    categoryInput.addEventListener('input', () => {
      formDirty = true;
      showCategoryDropdown(false);
    });

    document.addEventListener('click', (e) => {
      if (e.target !== categoryInput && !categoryDropdown.contains(e.target)) {
        hideCategoryDropdown();
      }
    });

    [nameInput, imageInput, qtyInput, stockInput, priceInput, noteInput].forEach(el => {
      el.addEventListener('input', () => {
        formDirty = true;
      });
    });

    saveBtn.addEventListener('click', () => upsertItemFromForm(false));
    resetBtn.addEventListener('click', resetForm);
    deleteItemBtn.addEventListener('click', () => {
      deleteCurrentItem();
    });
    imageInput.addEventListener('input', updateImageThumbFromInput);

    csvFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        parseCsv(event.target.result);
      };
      reader.readAsText(file, 'utf-8');
    });

    exportBtn.addEventListener('click', exportCsv);

    githubPullBtn.addEventListener('click', githubPullCsv);
    githubPushBtn.addEventListener('click', githubPushCsv);

    cameraBtn.addEventListener('click', () => {
      if (scanning) {
        stopCameraScan();
      } else {
        stopPhotoCamera();
        startCameraScan();
      }
    });

    stopCameraBtn.addEventListener('click', stopCameraScan);

    photoBtn.addEventListener('click', () => {
      stopCameraScan();
      if (photoStream) {
        stopPhotoCamera();
      } else {
        startPhotoCamera();
      }
    });

    takePhotoBtn.addEventListener('click', takePhoto);
    closePhotoBtn.addEventListener('click', stopPhotoCamera);

    searchNameBtn.addEventListener('click', searchByName);
    nameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchByName();
      }
    });

    editBarcodeModeBtn.addEventListener('click', () => {
      editBarcodeMode = !editBarcodeMode;
      if (editBarcodeMode) {
        editBarcodeModeBtn.textContent = '‚úÖ ƒêang s·ª≠a m√£ (t·∫Øt auto qu√©t)';
        editBarcodeModeBtn.style.background = '#ffe8cc';
      } else {
        editBarcodeModeBtn.textContent = '‚úèÔ∏è S·ª≠a m√£';
        editBarcodeModeBtn.style.background = '';
      }
    });

    loadFromLocalStorage();
    barcodeInput.focus();
    updateImageThumbFromInput();
    initGithubAuto();
  </script>
</body>
</html>
